const t=Math.pow(2,-52),i=new Uint32Array(512);class n{static from(t){const i=t.length,s=new Float64Array(2*i);for(let n=0;n<i;n++){const i=t[n];s[2*n]=i[0],s[2*n+1]=i[1]}return new n(s)}constructor(i){const n=i.length>>1;if(n>0&&"number"!=typeof i[0])throw new Error("Expected coords to contain numbers.");this.coords=i;const s=2*n-5,r=this.triangles=new Uint32Array(3*s),c=this.halfedges=new Int32Array(3*s);this._hashSize=Math.ceil(Math.sqrt(n));const f=this.hullPrev=new Uint32Array(n),u=this.hullNext=new Uint32Array(n),y=this.hullTri=new Uint32Array(n),_=new Int32Array(this._hashSize).fill(-1),g=new Uint32Array(n);let d=Infinity,w=Infinity,M=-Infinity,x=-Infinity;for(let t=0;t<n;t++){const n=i[2*t],s=i[2*t+1];n<d&&(d=n),s<w&&(w=s),n>M&&(M=n),s>x&&(x=s),g[t]=t}const b=(d+M)/2,k=(w+x)/2;let A,S,z,I=Infinity;for(let t=0;t<n;t++){const n=e(b,k,i[2*t],i[2*t+1]);n<I&&(A=t,I=n)}const T=i[2*A],U=i[2*A+1];I=Infinity;for(let t=0;t<n;t++){if(t===A)continue;const n=e(T,U,i[2*t],i[2*t+1]);n<I&&n>0&&(S=t,I=n)}let K=i[2*S],m=i[2*S+1],p=Infinity;for(let t=0;t<n;t++){if(t===A||t===S)continue;const n=l(T,U,K,m,i[2*t],i[2*t+1]);n<p&&(z=t,p=n)}let L=i[2*z],N=i[2*z+1];if(Infinity===p)throw new Error("No Delaunay triangulation exists for this input.");if(h(T,U,K,m,L,N)){const t=S,i=K,n=m;S=z,K=L,m=N,z=t,L=i,N=n}const q=a(T,U,K,m,L,N);this._cx=q.x,this._cy=q.y;const E=new Float64Array(n);for(let t=0;t<n;t++)E[t]=e(i[2*t],i[2*t+1],q.x,q.y);o(g,E,0,n-1),this.hullStart=A;let v=3;u[A]=f[z]=S,u[S]=f[A]=z,u[z]=f[S]=A,y[A]=0,y[S]=1,y[z]=2,_[this._hashKey(T,U)]=A,_[this._hashKey(K,m)]=S,_[this._hashKey(L,N)]=z,this.trianglesLen=0,this._addTriangle(A,S,z,-1,-1,-1);for(let n,s,e=0;e<g.length;e++){const r=g[e],l=i[2*r],a=i[2*r+1];if(e>0&&Math.abs(l-n)<=t&&Math.abs(a-s)<=t)continue;if(n=l,s=a,r===A||r===S||r===z)continue;let o=0;for(let t=0,i=this._hashKey(l,a);t<this._hashSize&&(o=_[(i+t)%this._hashSize],-1===o||o===u[o]);t++);o=f[o];let c,d=o;for(;c=u[d],!h(l,a,i[2*d],i[2*d+1],i[2*c],i[2*c+1]);)if(d=c,d===o){d=-1;break}if(-1===d)continue;let w=this._addTriangle(d,r,u[d],-1,-1,y[d]);y[r]=this._legalize(w+2),y[d]=w,v++;let M=u[d];for(;c=u[M],h(l,a,i[2*M],i[2*M+1],i[2*c],i[2*c+1]);)w=this._addTriangle(M,r,c,y[r],-1,y[M]),y[r]=this._legalize(w+2),u[M]=M,v--,M=c;if(d===o)for(;c=f[d],h(l,a,i[2*c],i[2*c+1],i[2*d],i[2*d+1]);)w=this._addTriangle(c,r,d,-1,y[d],y[c]),this._legalize(w+2),y[c]=w,u[d]=d,v--,d=c;this.hullStart=f[r]=d,u[d]=f[M]=r,u[r]=M,_[this._hashKey(l,a)]=r,_[this._hashKey(i[2*d],i[2*d+1])]=d}this.hull=new Uint32Array(v);for(let t=0,i=this.hullStart;t<v;t++)this.hull[t]=i,i=u[i];this.hullPrev=this.hullNext=this.hullTri=null,this.triangles=r.subarray(0,this.trianglesLen),this.halfedges=c.subarray(0,this.trianglesLen)}_hashKey(t,i){return Math.floor(s(t-this._cx,i-this._cy)*this._hashSize)%this._hashSize}_legalize(t){const{triangles:n,coords:s,halfedges:e}=this;let h=0,l=0;for(;;){const a=e[t],o=t-t%3;if(l=o+(t+2)%3,-1===a){if(0===h)break;t=i[--h];continue}const c=a-a%3,f=c+(a+2)%3,u=n[l],y=n[t],_=n[o+(t+1)%3],g=n[f];if(r(s[2*u],s[2*u+1],s[2*y],s[2*y+1],s[2*_],s[2*_+1],s[2*g],s[2*g+1])){n[t]=g,n[a]=u;const s=e[f];if(-1===s){let i=this.hullStart;do{if(this.hullTri[i]===f){this.hullTri[i]=t;break}i=this.hullNext[i]}while(i!==this.hullStart)}this._link(t,s),this._link(a,e[l]),this._link(l,f);const r=c+(a+1)%3;h<i.length&&(i[h++]=r)}else{if(0===h)break;t=i[--h]}}return l}_link(t,i){this.halfedges[t]=i,-1!==i&&(this.halfedges[i]=t)}_addTriangle(t,i,n,s,e,h){const r=this.trianglesLen;return this.triangles[r]=t,this.triangles[r+1]=i,this.triangles[r+2]=n,this._link(r,s),this._link(r+1,e),this._link(r+2,h),this.trianglesLen+=3,r}}function s(t,i){const n=t/(Math.abs(t)+Math.abs(i));return(i>0?3-n:1+n)/4}function e(t,i,n,s){const e=t-n,h=i-s;return e*e+h*h}function h(t,i,n,s,e,h){return(s-i)*(e-n)-(n-t)*(h-s)<0}function r(t,i,n,s,e,h,r,l){const a=t-r,o=i-l,c=n-r,f=s-l,u=e-r,y=h-l,_=c*c+f*f,g=u*u+y*y;return a*(f*g-_*y)-o*(c*g-_*u)+(a*a+o*o)*(c*y-f*u)<0}function l(t,i,n,s,e,h){const r=n-t,l=s-i,a=e-t,o=h-i,c=r*r+l*l,f=a*a+o*o,u=.5/(r*o-l*a),y=(o*c-l*f)*u,_=(r*f-a*c)*u;return y*y+_*_}function a(t,i,n,s,e,h){const r=n-t,l=s-i,a=e-t,o=h-i,c=r*r+l*l,f=a*a+o*o,u=.5/(r*o-l*a);return{x:t+(o*c-l*f)*u,y:i+(r*f-a*c)*u}}function o(t,i,n,s){if(s-n<=20)for(let e=n+1;e<=s;e++){const s=t[e],h=i[s];let r=e-1;for(;r>=n&&i[t[r]]>h;)t[r+1]=t[r--];t[r+1]=s}else{let e=n+1,h=s;c(t,n+s>>1,e),i[t[n]]>i[t[s]]&&c(t,n,s),i[t[e]]>i[t[s]]&&c(t,e,s),i[t[n]]>i[t[e]]&&c(t,n,e);const r=t[e],l=i[r];for(;;){do{e++}while(i[t[e]]<l);do{h--}while(i[t[h]]>l);if(h<e)break;c(t,e,h)}t[n+1]=t[h],t[h]=r,s-e+1>=h-n?(o(t,i,e,s),o(t,i,n,h-1)):(o(t,i,n,h-1),o(t,i,e,s))}}function c(t,i,n){const s=t[i];t[i]=t[n],t[n]=s}function f(t=1){const i=[[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],n=new Uint8Array(512),s=(Math.sqrt(3)-1)/2,e=(3-Math.sqrt(3))/6,h=(t,i)=>t[0]*i[0]+t[1]*i[1],r=(t,i)=>[t[0]-i[0],t[1]-i[1]];return new class{constructor(t=1){for(let t=0;t<512;t++)n[t]=255&t;for(let i=0;i<255;i++){const s=(t=this.hash(i+t))%(256-i)+i,e=n[i];n[i+256]=n[i]=n[s],n[s+256]=n[s]=e}}noise2D(t){const l=h(t,[s,s]),a=[Math.floor(t[0]+l),Math.floor(t[1]+l)],o=255&a[0],c=255&a[1],f=h(a,[e,e]),u=r(t,r(a,[f,f])),y=u[0]>u[1]?[1,0]:[0,1],_=r(r(u,y),[-e,-e]),g=r(u,[1-2*e,1-2*e]);let d=Math.max(0,.5-h(u,u))**4*h(i[n[o+n[c]]%12],u);return d+=Math.max(0,.5-h(_,_))**4*h(i[n[o+y[0]+n[c+y[1]]]%12],_),d+=Math.max(0,.5-h(g,g))**4*h(i[n[o+1+n[c+1]]%12],g),70*d}hash(t){const i=1103515245*((t=1103515245*(t>>1^t))^t>>3);return i^i>>16}}(t)}export{n as Delaunator,f as SimplexNoise,a as circumcenter,l as circumradius,e as dist,r as inCircle,h as orient,s as pseudoAngle,o as quicksort,c as swap};
//# sourceMappingURL=index.modern.js.map
